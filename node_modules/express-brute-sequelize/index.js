// Generated by CoffeeScript 1.12.7
(function() {
  var AbstractClientStore, Sequelize, bruteStore, moment;

  AbstractClientStore = require('express-brute/lib/AbstractClientStore');

  moment = require('moment');

  Sequelize = require('sequelize');

  module.exports = bruteStore = (function() {
    function bruteStore(sequelize, table, options, callback) {
      AbstractClientStore.apply(this, arguments);
      this.defaults = {
        prefix: '',
        logging: false
      };
      this.options = Object.assign({}, this.defaults, options);
      this._table = sequelize.define(table, {
        _id: {
          type: Sequelize.STRING,
          unique: true
        },
        expires: {
          type: Sequelize.DATE
        },
        firstRequest: {
          type: Sequelize.DATE
        },
        lastRequest: {
          type: Sequelize.DATE
        },
        count: {
          type: Sequelize.INTEGER
        }
      });
      this._table.sync().then((function(_this) {
        return function() {
          if (_this.options.logging) {
            console.log("bruteStore initialized - table " + table + " created");
          }
          return callback(_this);
        };
      })(this))["catch"]((function(_this) {
        return function() {
          if (_this.options.logging) {
            console.log("Failed to initialize bruteStore - table " + table);
          }
          return callback(_this);
        };
      })(this));
    }

    bruteStore.prototype.set = function(key, value, lifetime, callback) {
      var _id, expiration;
      _id = this.options.prefix + key;
      expiration = lifetime ? (moment().add(lifetime, 'seconds')).toDate() : null;
      return this._table.find({
        where: {
          _id: _id
        }
      }).then((function(_this) {
        return function(doc) {
          if (doc) {
            doc._id = _id;
            doc.count = value.count;
            doc.lastRequest = value.lastRequest;
            doc.firstRequest = value.firstRequest;
            doc.expires = expiration;
            return doc.save();
          } else {
            return _this._table.create({
              _id: _id,
              count: value.count,
              lastRequest: value.lastRequest,
              firstRequest: value.firstRequest,
              expires: expiration
            });
          }
        };
      })(this)).then(function(doc) {
        typeof callback === 'function' && callback();
        return null;
      })["catch"](function(err) {
        typeof callback === 'function' && callback(err);
        return null;
      });
    };

    bruteStore.prototype.get = function(key, callback) {
      var _id;
      _id = this.options.prefix + key;
      return this._table.find({
        where: {
          _id: _id
        }
      }).then((function(_this) {
        return function(doc) {
          if (doc && new Date(doc.expires).getTime() < new Date().getTime()) {
            return _this._table.destroy({
              where: {
                "_id": _id
              }
            });
          }
          if (doc) {
            return Promise.resolve({
              count: doc.count,
              lastRequest: new Date(doc.lastRequest),
              firstRequest: new Date(doc.firstRequest)
            });
          }
          return Promise.resolve();
        };
      })(this)).then(function(data) {
        if (!data) {
          data = void 0;
        }
        typeof callback === 'function' && callback(null, data);
        return null;
      })["catch"](function(err) {
        typeof callback === 'function' && callback(err);
        return null;
      });
    };

    bruteStore.prototype.reset = function(key, callback) {
      var _id;
      _id = this.options.prefix + key;
      return this._table.destroy({
        where: {
          "_id": _id
        }
      }).then(function(doc) {
        return typeof callback === 'function' && callback(null, doc);
        return null;
      })["catch"](function(err) {
        return typeof callback === 'function' && callback(err, null);
        return null;
      });
    };

    return bruteStore;

  })();

}).call(this);
